<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>panda_mpc: franka_hw::FrankaHW Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">panda_mpc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>franka_hw</b></li><li class="navelem"><a class="el" href="classfranka__hw_1_1_franka_h_w.html">FrankaHW</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classfranka__hw_1_1_franka_h_w-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">franka_hw::FrankaHW Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="franka__hw_8h_source.html">franka_hw.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for franka_hw::FrankaHW:</div>
<div class="dyncontent">
<div class="center"><img src="classfranka__hw_1_1_franka_h_w__inherit__graph.png" border="0" usemap="#franka__hw_1_1_franka_h_w_inherit__map" alt="Inheritance graph"/></div>
<map name="franka__hw_1_1_franka_h_w_inherit__map" id="franka__hw_1_1_franka_h_w_inherit__map">
<area shape="rect" id="node3" href="classfranka__hw_1_1_franka_combinable_h_w.html" title="franka_hw::FrankaCombinableHW" alt="" coords="5,169,228,196"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for franka_hw::FrankaHW:</div>
<div class="dyncontent">
<div class="center"><img src="classfranka__hw_1_1_franka_h_w__coll__graph.png" border="0" usemap="#franka__hw_1_1_franka_h_w_coll__map" alt="Collaboration graph"/></div>
<map name="franka__hw_1_1_franka_h_w_coll__map" id="franka__hw_1_1_franka_h_w_coll__map">
<area shape="rect" id="node3" href="classfranka__hw_1_1_franka_state_interface.html" title="franka_hw::FrankaStateInterface" alt="" coords="310,71,522,98"/>
<area shape="rect" id="node5" href="classfranka__hw_1_1_franka_model_interface.html" title="franka_hw::FrankaModelInterface" alt="" coords="308,122,524,149"/>
<area shape="rect" id="node7" href="classfranka__hw_1_1_franka_velocity_cartesian_interface.html" title="franka_hw::FrankaVelocity\lCartesianInterface" alt="" coords="327,173,505,215"/>
<area shape="rect" id="node10" href="structfranka__hw_1_1_franka_h_w_1_1_collision_config.html" title="franka_hw::FrankaHW\l::CollisionConfig" alt="" coords="339,291,493,332"/>
<area shape="rect" id="node11" href="classfranka__hw_1_1_franka_pose_cartesian_interface.html" title="franka_hw::FrankaPoseCartesian\lInterface" alt="" coords="308,356,524,397"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfranka__hw_1_1_franka_h_w_1_1_collision_config.html">CollisionConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abca52ce19bfa28709efcfe8d0d6404b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#abca52ce19bfa28709efcfe8d0d6404b8">FrankaHW</a> ()</td></tr>
<tr class="separator:abca52ce19bfa28709efcfe8d0d6404b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0323c9d759de8d6ab8fae4bf574e4a48"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a0323c9d759de8d6ab8fae4bf574e4a48">init</a> (ros::NodeHandle &amp;root_nh, ros::NodeHandle &amp;robot_hw_nh) override</td></tr>
<tr class="separator:a0323c9d759de8d6ab8fae4bf574e4a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d479321248ff8bcf80fc73ebb95d16"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a55d479321248ff8bcf80fc73ebb95d16">initParameters</a> (ros::NodeHandle &amp;root_nh, ros::NodeHandle &amp;robot_hw_nh)</td></tr>
<tr class="separator:a55d479321248ff8bcf80fc73ebb95d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2775ed9705ec3d1d3e58aea2ce21bde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ae2775ed9705ec3d1d3e58aea2ce21bde">initROSInterfaces</a> (ros::NodeHandle &amp;robot_hw_nh)</td></tr>
<tr class="separator:ae2775ed9705ec3d1d3e58aea2ce21bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064557fa9f0f7cb8e7cfab27eae03eb8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a064557fa9f0f7cb8e7cfab27eae03eb8">setupParameterCallbacks</a> (ros::NodeHandle &amp;robot_hw_nh)</td></tr>
<tr class="separator:a064557fa9f0f7cb8e7cfab27eae03eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbafdee04c749eae1726dd6e76f52c0f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#abbafdee04c749eae1726dd6e76f52c0f">control</a> (const std::function&lt; bool(const ros::Time &amp;, const ros::Duration &amp;)&gt; &amp;ros_callback) const</td></tr>
<tr class="separator:abbafdee04c749eae1726dd6e76f52c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f348151b93a7eebc9ef45a702a29ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ad8f348151b93a7eebc9ef45a702a29ee">update</a> (const franka::RobotState &amp;robot_state)</td></tr>
<tr class="separator:ad8f348151b93a7eebc9ef45a702a29ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcc0a82b0c13cdbd1de7fea38c3ecc3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a8fcc0a82b0c13cdbd1de7fea38c3ecc3">controllerActive</a> () const noexcept</td></tr>
<tr class="separator:a8fcc0a82b0c13cdbd1de7fea38c3ecc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e581982455acacca51d81e4676e9a6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a73e581982455acacca51d81e4676e9a6">checkForConflict</a> (const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;info) const override</td></tr>
<tr class="separator:a73e581982455acacca51d81e4676e9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29812769471d212a30dac6c19c12884"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ab29812769471d212a30dac6c19c12884">doSwitch</a> (const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;, const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;) override</td></tr>
<tr class="separator:ab29812769471d212a30dac6c19c12884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73b14d5f8481cd3cb3d670aeae2de06"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ab73b14d5f8481cd3cb3d670aeae2de06">prepareSwitch</a> (const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;start_list, const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;stop_list) override</td></tr>
<tr class="separator:ab73b14d5f8481cd3cb3d670aeae2de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bc3da19575532ab827bc9c62f91bed"><td class="memItemLeft" align="right" valign="top">virtual std::array&lt; double, 7 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a80bc3da19575532ab827bc9c62f91bed">getJointPositionCommand</a> () const noexcept</td></tr>
<tr class="separator:a80bc3da19575532ab827bc9c62f91bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93067ec2c8ba530188ee70f024ddf100"><td class="memItemLeft" align="right" valign="top">virtual std::array&lt; double, 7 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a93067ec2c8ba530188ee70f024ddf100">getJointVelocityCommand</a> () const noexcept</td></tr>
<tr class="separator:a93067ec2c8ba530188ee70f024ddf100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8063f56d7e70e0f7537fe1d522f8f2f"><td class="memItemLeft" align="right" valign="top">virtual std::array&lt; double, 7 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ae8063f56d7e70e0f7537fe1d522f8f2f">getJointEffortCommand</a> () const noexcept</td></tr>
<tr class="separator:ae8063f56d7e70e0f7537fe1d522f8f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0f49fec764be80e4c89e29706a4936"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#afb0f49fec764be80e4c89e29706a4936">enforceLimits</a> (const ros::Duration &amp;period)</td></tr>
<tr class="separator:afb0f49fec764be80e4c89e29706a4936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0bc020099cb6dba41728252d0c7df4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#aaa0bc020099cb6dba41728252d0c7df4">reset</a> ()</td></tr>
<tr class="separator:aaa0bc020099cb6dba41728252d0c7df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120261c13cfa7f508061dd5c81d080e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a120261c13cfa7f508061dd5c81d080e5">checkJointLimits</a> ()</td></tr>
<tr class="separator:a120261c13cfa7f508061dd5c81d080e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8494bbab229cd16bc9bb7c994b01684d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a8494bbab229cd16bc9bb7c994b01684d">read</a> (const ros::Time &amp;time, const ros::Duration &amp;period) override</td></tr>
<tr class="separator:a8494bbab229cd16bc9bb7c994b01684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdec49ec8bb07c48ed3d77ea2cd4e46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#afcdec49ec8bb07c48ed3d77ea2cd4e46">write</a> (const ros::Time &amp;time, const ros::Duration &amp;period) override</td></tr>
<tr class="separator:afcdec49ec8bb07c48ed3d77ea2cd4e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade38eaa271d71cebb8bce3635cf82169"><td class="memItemLeft" align="right" valign="top">virtual franka::Robot &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ade38eaa271d71cebb8bce3635cf82169">robot</a> () const</td></tr>
<tr class="separator:ade38eaa271d71cebb8bce3635cf82169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a673cc620d6acb15625f6403d96c75f4e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a673cc620d6acb15625f6403d96c75f4e">commandHasNaN</a> (const franka::Torques &amp;command)</td></tr>
<tr class="separator:a673cc620d6acb15625f6403d96c75f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f7dda7266b381a4c779993b4d0185f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a32f7dda7266b381a4c779993b4d0185f">commandHasNaN</a> (const franka::JointPositions &amp;command)</td></tr>
<tr class="separator:a32f7dda7266b381a4c779993b4d0185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bc8a84589c605327e9bbcb64809fe1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a56bc8a84589c605327e9bbcb64809fe1">commandHasNaN</a> (const franka::JointVelocities &amp;command)</td></tr>
<tr class="separator:a56bc8a84589c605327e9bbcb64809fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec15cdb4cd9edb0976e96c63b62f93c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#aeec15cdb4cd9edb0976e96c63b62f93c">commandHasNaN</a> (const franka::CartesianPose &amp;command)</td></tr>
<tr class="separator:aeec15cdb4cd9edb0976e96c63b62f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac408df87375bb8cfde94f4e5bf4a16c2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ac408df87375bb8cfde94f4e5bf4a16c2">commandHasNaN</a> (const franka::CartesianVelocities &amp;command)</td></tr>
<tr class="separator:ac408df87375bb8cfde94f4e5bf4a16c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac576bd5140a03864888c68519daa5aa4"><td class="memItemLeft" align="right" valign="top"><a id="ac576bd5140a03864888c68519daa5aa4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Callback</b> = std::function&lt; bool(const franka::RobotState &amp;, franka::Duration)&gt;</td></tr>
<tr class="separator:ac576bd5140a03864888c68519daa5aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4014fbce5bae60ee693505775ecee499"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4014fbce5bae60ee693505775ecee499"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a4014fbce5bae60ee693505775ecee499">controlCallback</a> (const T &amp;command, Callback ros_callback, const franka::RobotState &amp;robot_state, franka::Duration time_step)</td></tr>
<tr class="separator:a4014fbce5bae60ee693505775ecee499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a476a1de741f79695f0b64d2580e6cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a476a1de741f79695f0b64d2580e6cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a3a476a1de741f79695f0b64d2580e6cf">setupLimitInterface</a> (joint_limits_interface::JointLimitsInterface&lt; T &gt; &amp;limit_interface, hardware_interface::JointCommandInterface &amp;command_interface)</td></tr>
<tr class="separator:a3a476a1de741f79695f0b64d2580e6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab216faba5316b7ca1680e9af5d313216"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ab216faba5316b7ca1680e9af5d313216">setupJointStateInterface</a> (franka::RobotState &amp;robot_state)</td></tr>
<tr class="separator:ab216faba5316b7ca1680e9af5d313216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e707d6e834267f1ad256da5cce0713"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34e707d6e834267f1ad256da5cce0713"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a34e707d6e834267f1ad256da5cce0713">setupJointCommandInterface</a> (std::array&lt; double, 7 &gt; &amp;command, franka::RobotState &amp;state, bool use_q_d, T &amp;interface)</td></tr>
<tr class="separator:a34e707d6e834267f1ad256da5cce0713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbc96ed57e3054db31bbab11a61afec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a4dbc96ed57e3054db31bbab11a61afec">setupFrankaStateInterface</a> (franka::RobotState &amp;robot_state)</td></tr>
<tr class="separator:a4dbc96ed57e3054db31bbab11a61afec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16128e9789d933e1fcb3f9fc6e336eb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a16128e9789d933e1fcb3f9fc6e336eb1">setupFrankaCartesianPoseInterface</a> (franka::CartesianPose &amp;pose_cartesian_command)</td></tr>
<tr class="separator:a16128e9789d933e1fcb3f9fc6e336eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e7f8225648735e054d8b022efee557"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a60e7f8225648735e054d8b022efee557">setupFrankaCartesianVelocityInterface</a> (franka::CartesianVelocities &amp;velocity_cartesian_command)</td></tr>
<tr class="separator:a60e7f8225648735e054d8b022efee557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d738b3573b7ab159209b7e2e0d4a802"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a4d738b3573b7ab159209b7e2e0d4a802">setupFrankaModelInterface</a> (franka::RobotState &amp;robot_state)</td></tr>
<tr class="separator:a4d738b3573b7ab159209b7e2e0d4a802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910bb11c6a3b14f027ad56dcf0d983c7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a910bb11c6a3b14f027ad56dcf0d983c7">setRunFunction</a> (const ControlMode &amp;requested_control_mode, bool limit_rate, double cutoff_frequency, franka::ControllerMode internal_controller)</td></tr>
<tr class="separator:a910bb11c6a3b14f027ad56dcf0d983c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad211498ff17ff1dfb9609a2fcf76d14a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#ad211498ff17ff1dfb9609a2fcf76d14a">initRobot</a> ()</td></tr>
<tr class="separator:ad211498ff17ff1dfb9609a2fcf76d14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a6adcd4d0cf60dd255bfea0d80791fcc7"><td class="memTemplParams" colspan="2">template&lt;size_t size&gt; </td></tr>
<tr class="memitem:a6adcd4d0cf60dd255bfea0d80791fcc7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a6adcd4d0cf60dd255bfea0d80791fcc7">arrayHasNaN</a> (const std::array&lt; double, size &gt; &amp;array)</td></tr>
<tr class="separator:a6adcd4d0cf60dd255bfea0d80791fcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f811d66ca087ad8ca387f7767e1df5f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfranka__hw_1_1_franka_h_w.html#a2f811d66ca087ad8ca387f7767e1df5f">getCollisionThresholds</a> (const std::string &amp;name, ros::NodeHandle &amp;robot_hw_nh, const std::vector&lt; double &gt; &amp;defaults)</td></tr>
<tr class="separator:a2f811d66ca087ad8ca387f7767e1df5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adc6ac201c82bfe71c0309cd32e361cdf"><td class="memItemLeft" align="right" valign="top"><a id="adc6ac201c82bfe71c0309cd32e361cdf"></a>
<a class="el" href="structfranka__hw_1_1_franka_h_w_1_1_collision_config.html">CollisionConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><b>collision_config_</b></td></tr>
<tr class="separator:adc6ac201c82bfe71c0309cd32e361cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a3f8c221792e3d833ac3d50e61a8fc"><td class="memItemLeft" align="right" valign="top"><a id="a71a3f8c221792e3d833ac3d50e61a8fc"></a>
hardware_interface::JointStateInterface&#160;</td><td class="memItemRight" valign="bottom"><b>joint_state_interface_</b> {}</td></tr>
<tr class="separator:a71a3f8c221792e3d833ac3d50e61a8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b197ae6181a03bc25875a7e5231d6c2"><td class="memItemLeft" align="right" valign="top"><a id="a2b197ae6181a03bc25875a7e5231d6c2"></a>
<a class="el" href="classfranka__hw_1_1_franka_state_interface.html">FrankaStateInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><b>franka_state_interface_</b> {}</td></tr>
<tr class="separator:a2b197ae6181a03bc25875a7e5231d6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed81f869c0785e8257c9b21ce3a54f48"><td class="memItemLeft" align="right" valign="top"><a id="aed81f869c0785e8257c9b21ce3a54f48"></a>
hardware_interface::PositionJointInterface&#160;</td><td class="memItemRight" valign="bottom"><b>position_joint_interface_</b> {}</td></tr>
<tr class="separator:aed81f869c0785e8257c9b21ce3a54f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae00e8f592019644703aaebcc8b6d8db"><td class="memItemLeft" align="right" valign="top"><a id="aae00e8f592019644703aaebcc8b6d8db"></a>
hardware_interface::VelocityJointInterface&#160;</td><td class="memItemRight" valign="bottom"><b>velocity_joint_interface_</b> {}</td></tr>
<tr class="separator:aae00e8f592019644703aaebcc8b6d8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f695d0eb767c02397372cb5536db00c"><td class="memItemLeft" align="right" valign="top"><a id="a5f695d0eb767c02397372cb5536db00c"></a>
hardware_interface::EffortJointInterface&#160;</td><td class="memItemRight" valign="bottom"><b>effort_joint_interface_</b> {}</td></tr>
<tr class="separator:a5f695d0eb767c02397372cb5536db00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7086c73e105997fe775d873ece1a177b"><td class="memItemLeft" align="right" valign="top"><a id="a7086c73e105997fe775d873ece1a177b"></a>
<a class="el" href="classfranka__hw_1_1_franka_pose_cartesian_interface.html">FrankaPoseCartesianInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><b>franka_pose_cartesian_interface_</b> {}</td></tr>
<tr class="separator:a7086c73e105997fe775d873ece1a177b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d77bce759ddf1db22a22a996181ba9"><td class="memItemLeft" align="right" valign="top"><a id="af8d77bce759ddf1db22a22a996181ba9"></a>
<a class="el" href="classfranka__hw_1_1_franka_velocity_cartesian_interface.html">FrankaVelocityCartesianInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><b>franka_velocity_cartesian_interface_</b> {}</td></tr>
<tr class="separator:af8d77bce759ddf1db22a22a996181ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8480f1a38f8a01fb10670f9d300ed037"><td class="memItemLeft" align="right" valign="top"><a id="a8480f1a38f8a01fb10670f9d300ed037"></a>
<a class="el" href="classfranka__hw_1_1_franka_model_interface.html">FrankaModelInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><b>franka_model_interface_</b> {}</td></tr>
<tr class="separator:a8480f1a38f8a01fb10670f9d300ed037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0453d8d00992ae08ddd47083a21abcc8"><td class="memItemLeft" align="right" valign="top"><a id="a0453d8d00992ae08ddd47083a21abcc8"></a>
joint_limits_interface::PositionJointSoftLimitsInterface&#160;</td><td class="memItemRight" valign="bottom"><b>position_joint_limit_interface_</b> {}</td></tr>
<tr class="separator:a0453d8d00992ae08ddd47083a21abcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e85e4440436f97a169553d281049e4e"><td class="memItemLeft" align="right" valign="top"><a id="a4e85e4440436f97a169553d281049e4e"></a>
joint_limits_interface::VelocityJointSoftLimitsInterface&#160;</td><td class="memItemRight" valign="bottom"><b>velocity_joint_limit_interface_</b> {}</td></tr>
<tr class="separator:a4e85e4440436f97a169553d281049e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3545598adde92a2cd78af121bf40f24b"><td class="memItemLeft" align="right" valign="top"><a id="a3545598adde92a2cd78af121bf40f24b"></a>
joint_limits_interface::EffortJointSoftLimitsInterface&#160;</td><td class="memItemRight" valign="bottom"><b>effort_joint_limit_interface_</b> {}</td></tr>
<tr class="separator:a3545598adde92a2cd78af121bf40f24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2de5dd88993549670b2345fbf70c539"><td class="memItemLeft" align="right" valign="top"><a id="af2de5dd88993549670b2345fbf70c539"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>libfranka_state_mutex_</b></td></tr>
<tr class="separator:af2de5dd88993549670b2345fbf70c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e2b2029bc0a45bb28594435097434d"><td class="memItemLeft" align="right" valign="top"><a id="a80e2b2029bc0a45bb28594435097434d"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>ros_state_mutex_</b></td></tr>
<tr class="separator:a80e2b2029bc0a45bb28594435097434d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe80f4d54e4f6aa47534ebbcb2382ecb"><td class="memItemLeft" align="right" valign="top"><a id="afe80f4d54e4f6aa47534ebbcb2382ecb"></a>
franka::RobotState&#160;</td><td class="memItemRight" valign="bottom"><b>robot_state_libfranka_</b> {}</td></tr>
<tr class="separator:afe80f4d54e4f6aa47534ebbcb2382ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87c69ba0fb5281e2bbe1ad819fb02b5"><td class="memItemLeft" align="right" valign="top"><a id="aa87c69ba0fb5281e2bbe1ad819fb02b5"></a>
franka::RobotState&#160;</td><td class="memItemRight" valign="bottom"><b>robot_state_ros_</b> {}</td></tr>
<tr class="separator:aa87c69ba0fb5281e2bbe1ad819fb02b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01434e76a69afa29f009de2aacd5a0c0"><td class="memItemLeft" align="right" valign="top"><a id="a01434e76a69afa29f009de2aacd5a0c0"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>libfranka_cmd_mutex_</b></td></tr>
<tr class="separator:a01434e76a69afa29f009de2aacd5a0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe1fb5677162020a5a68dbf33dcf2a8"><td class="memItemLeft" align="right" valign="top"><a id="a7fe1fb5677162020a5a68dbf33dcf2a8"></a>
franka::JointPositions&#160;</td><td class="memItemRight" valign="bottom"><b>position_joint_command_libfranka_</b></td></tr>
<tr class="separator:a7fe1fb5677162020a5a68dbf33dcf2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97615d220402aec7723b2a0edeb52043"><td class="memItemLeft" align="right" valign="top"><a id="a97615d220402aec7723b2a0edeb52043"></a>
franka::JointVelocities&#160;</td><td class="memItemRight" valign="bottom"><b>velocity_joint_command_libfranka_</b></td></tr>
<tr class="separator:a97615d220402aec7723b2a0edeb52043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab481fa379d12af7339a2fc84a5351090"><td class="memItemLeft" align="right" valign="top"><a id="ab481fa379d12af7339a2fc84a5351090"></a>
franka::Torques&#160;</td><td class="memItemRight" valign="bottom"><b>effort_joint_command_libfranka_</b></td></tr>
<tr class="separator:ab481fa379d12af7339a2fc84a5351090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcf6ae0cb54478065f7bdb4cebc3684"><td class="memItemLeft" align="right" valign="top"><a id="a4bcf6ae0cb54478065f7bdb4cebc3684"></a>
franka::CartesianPose&#160;</td><td class="memItemRight" valign="bottom"><b>pose_cartesian_command_libfranka_</b></td></tr>
<tr class="separator:a4bcf6ae0cb54478065f7bdb4cebc3684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000ca0dd3d505f095fa9ee17967b7563"><td class="memItemLeft" align="right" valign="top"><a id="a000ca0dd3d505f095fa9ee17967b7563"></a>
franka::CartesianVelocities&#160;</td><td class="memItemRight" valign="bottom"><b>velocity_cartesian_command_libfranka_</b></td></tr>
<tr class="separator:a000ca0dd3d505f095fa9ee17967b7563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23bd816eecbd232ca2df39dc5e3f8b4"><td class="memItemLeft" align="right" valign="top"><a id="aa23bd816eecbd232ca2df39dc5e3f8b4"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>ros_cmd_mutex_</b></td></tr>
<tr class="separator:aa23bd816eecbd232ca2df39dc5e3f8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d65810b55198d9691b25bf3c6ecbc00"><td class="memItemLeft" align="right" valign="top"><a id="a1d65810b55198d9691b25bf3c6ecbc00"></a>
franka::JointPositions&#160;</td><td class="memItemRight" valign="bottom"><b>position_joint_command_ros_</b></td></tr>
<tr class="separator:a1d65810b55198d9691b25bf3c6ecbc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce1c75e2e75aa476df6e239b9092b11"><td class="memItemLeft" align="right" valign="top"><a id="a2ce1c75e2e75aa476df6e239b9092b11"></a>
franka::JointVelocities&#160;</td><td class="memItemRight" valign="bottom"><b>velocity_joint_command_ros_</b></td></tr>
<tr class="separator:a2ce1c75e2e75aa476df6e239b9092b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd805f67e92fb88bd8b218f65a7c911"><td class="memItemLeft" align="right" valign="top"><a id="abcd805f67e92fb88bd8b218f65a7c911"></a>
franka::Torques&#160;</td><td class="memItemRight" valign="bottom"><b>effort_joint_command_ros_</b></td></tr>
<tr class="separator:abcd805f67e92fb88bd8b218f65a7c911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5962dbb07400fffe3a93aa51a6ba74"><td class="memItemLeft" align="right" valign="top"><a id="a9d5962dbb07400fffe3a93aa51a6ba74"></a>
franka::CartesianPose&#160;</td><td class="memItemRight" valign="bottom"><b>pose_cartesian_command_ros_</b></td></tr>
<tr class="separator:a9d5962dbb07400fffe3a93aa51a6ba74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84657c0511e75821c08a6ea51b51a86"><td class="memItemLeft" align="right" valign="top"><a id="ac84657c0511e75821c08a6ea51b51a86"></a>
franka::CartesianVelocities&#160;</td><td class="memItemRight" valign="bottom"><b>velocity_cartesian_command_ros_</b></td></tr>
<tr class="separator:ac84657c0511e75821c08a6ea51b51a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92d666e7ded9c9c24db7418d0fedb88"><td class="memItemLeft" align="right" valign="top"><a id="ad92d666e7ded9c9c24db7418d0fedb88"></a>
std::unique_ptr&lt; franka::Robot &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>robot_</b></td></tr>
<tr class="separator:ad92d666e7ded9c9c24db7418d0fedb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4f13a4df9617f50df10ae4e4d6c536"><td class="memItemLeft" align="right" valign="top"><a id="a3f4f13a4df9617f50df10ae4e4d6c536"></a>
std::unique_ptr&lt; franka::Model &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>model_</b></td></tr>
<tr class="separator:a3f4f13a4df9617f50df10ae4e4d6c536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209e8f3424efe0fd05725be609d7205a"><td class="memItemLeft" align="right" valign="top"><a id="a209e8f3424efe0fd05725be609d7205a"></a>
std::array&lt; std::string, 7 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>joint_names_</b></td></tr>
<tr class="separator:a209e8f3424efe0fd05725be609d7205a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b5be24f33b2253a637d74ebdd66fa0"><td class="memItemLeft" align="right" valign="top"><a id="a97b5be24f33b2253a637d74ebdd66fa0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>arm_id_</b></td></tr>
<tr class="separator:a97b5be24f33b2253a637d74ebdd66fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3373d4deb835fd0a825c14c31b073"><td class="memItemLeft" align="right" valign="top"><a id="a88a3373d4deb835fd0a825c14c31b073"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>robot_ip_</b></td></tr>
<tr class="separator:a88a3373d4deb835fd0a825c14c31b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6965976c623e2ea3c460611d113858b"><td class="memItemLeft" align="right" valign="top"><a id="ae6965976c623e2ea3c460611d113858b"></a>
urdf::Model&#160;</td><td class="memItemRight" valign="bottom"><b>urdf_model_</b></td></tr>
<tr class="separator:ae6965976c623e2ea3c460611d113858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3881414ad06c12e6f747c7054fbc1092"><td class="memItemLeft" align="right" valign="top"><a id="a3881414ad06c12e6f747c7054fbc1092"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>joint_limit_warning_threshold_</b> {0.1}</td></tr>
<tr class="separator:a3881414ad06c12e6f747c7054fbc1092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193b40f1d42ff3f1b805bbef4a9c2749"><td class="memItemLeft" align="right" valign="top"><a id="a193b40f1d42ff3f1b805bbef4a9c2749"></a>
franka::RealtimeConfig&#160;</td><td class="memItemRight" valign="bottom"><b>realtime_config_</b></td></tr>
<tr class="separator:a193b40f1d42ff3f1b805bbef4a9c2749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08acb4bfdbe78711dc466e74ee56a61d"><td class="memItemLeft" align="right" valign="top"><a id="a08acb4bfdbe78711dc466e74ee56a61d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initialized_</b> {false}</td></tr>
<tr class="separator:a08acb4bfdbe78711dc466e74ee56a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa207ee4ba133fdb1b3887c9639b47b40"><td class="memItemLeft" align="right" valign="top"><a id="aa207ee4ba133fdb1b3887c9639b47b40"></a>
std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><b>controller_active_</b> {false}</td></tr>
<tr class="separator:aa207ee4ba133fdb1b3887c9639b47b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb4ed0043449742cadefa5809d9c6f0"><td class="memItemLeft" align="right" valign="top"><a id="a4eb4ed0043449742cadefa5809d9c6f0"></a>
ControlMode&#160;</td><td class="memItemRight" valign="bottom"><b>current_control_mode_</b> = ControlMode::None</td></tr>
<tr class="separator:a4eb4ed0043449742cadefa5809d9c6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2aab0e386f9ed57345cd56f02643ac"><td class="memItemLeft" align="right" valign="top"><a id="a0e2aab0e386f9ed57345cd56f02643ac"></a>
std::function&lt; franka::ControllerMode()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_internal_controller_</b></td></tr>
<tr class="separator:a0e2aab0e386f9ed57345cd56f02643ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d26d3a30e63e83e19cad138a9811fc7"><td class="memItemLeft" align="right" valign="top"><a id="a0d26d3a30e63e83e19cad138a9811fc7"></a>
std::function&lt; bool()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_limit_rate_</b></td></tr>
<tr class="separator:a0d26d3a30e63e83e19cad138a9811fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3ea355cd85b06247ee9def60485240"><td class="memItemLeft" align="right" valign="top"><a id="ada3ea355cd85b06247ee9def60485240"></a>
std::function&lt; double()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_cutoff_frequency_</b></td></tr>
<tr class="separator:ada3ea355cd85b06247ee9def60485240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53d17aecdb62936defdcde99e9b88b8"><td class="memItemLeft" align="right" valign="top"><a id="ab53d17aecdb62936defdcde99e9b88b8"></a>
std::function&lt; void(franka::Robot &amp;, Callback)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>run_function_</b></td></tr>
<tr class="separator:ab53d17aecdb62936defdcde99e9b88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class wraps the functionality of libfranka for controlling Panda robots into the ros_control framework. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abca52ce19bfa28709efcfe8d0d6404b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca52ce19bfa28709efcfe8d0d6404b8">&#9670;&nbsp;</a></span>FrankaHW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">franka_hw::FrankaHW::FrankaHW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Note: Be sure to call the <a class="el" href="classfranka__hw_1_1_franka_h_w.html#a0323c9d759de8d6ab8fae4bf574e4a48">init()</a> method before operation. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6adcd4d0cf60dd255bfea0d80791fcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adcd4d0cf60dd255bfea0d80791fcc7">&#9670;&nbsp;</a></span>arrayHasNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool franka_hw::FrankaHW::arrayHasNaN </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether an array of doubles contains NaN values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>array The array to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the array contains NaN values, false otherwise. </dd></dl>

</div>
</div>
<a id="a73e581982455acacca51d81e4676e9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e581982455acacca51d81e4676e9a6">&#9670;&nbsp;</a></span>checkForConflict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::checkForConflict </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether a requested controller can be run, based on the resources and interfaces it claims.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Controllers to be running at the same time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of a conflict, false in case of valid controllers. </dd></dl>

<p>Reimplemented in <a class="el" href="classfranka__hw_1_1_franka_combinable_h_w.html#aa2a84c1da5161ddb38e33f112c8850a7">franka_hw::FrankaCombinableHW</a>.</p>

</div>
</div>
<a id="a120261c13cfa7f508061dd5c81d080e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120261c13cfa7f508061dd5c81d080e5">&#9670;&nbsp;</a></span>checkJointLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::checkJointLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the proximity of each joint to its joint position limits and prints a warning whenever a joint is close to a limit. </p>

</div>
</div>
<a id="a673cc620d6acb15625f6403d96c75f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673cc620d6acb15625f6403d96c75f4e">&#9670;&nbsp;</a></span>commandHasNaN() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::commandHasNaN </td>
          <td>(</td>
          <td class="paramtype">const franka::Torques &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks a command for NaN values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The command to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command contains NaN, false otherwise. </dd></dl>

</div>
</div>
<a id="a32f7dda7266b381a4c779993b4d0185f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f7dda7266b381a4c779993b4d0185f">&#9670;&nbsp;</a></span>commandHasNaN() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::commandHasNaN </td>
          <td>(</td>
          <td class="paramtype">const franka::JointPositions &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks a command for NaN values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The command to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command contains NaN, false otherwise. </dd></dl>

</div>
</div>
<a id="a56bc8a84589c605327e9bbcb64809fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bc8a84589c605327e9bbcb64809fe1">&#9670;&nbsp;</a></span>commandHasNaN() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::commandHasNaN </td>
          <td>(</td>
          <td class="paramtype">const franka::JointVelocities &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks a command for NaN values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The command to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command contains NaN, false otherwise. </dd></dl>

</div>
</div>
<a id="aeec15cdb4cd9edb0976e96c63b62f93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec15cdb4cd9edb0976e96c63b62f93c">&#9670;&nbsp;</a></span>commandHasNaN() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::commandHasNaN </td>
          <td>(</td>
          <td class="paramtype">const franka::CartesianPose &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks a command for NaN values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The command to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command contains NaN, false otherwise. </dd></dl>

</div>
</div>
<a id="ac408df87375bb8cfde94f4e5bf4a16c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac408df87375bb8cfde94f4e5bf4a16c2">&#9670;&nbsp;</a></span>commandHasNaN() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::commandHasNaN </td>
          <td>(</td>
          <td class="paramtype">const franka::CartesianVelocities &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks a command for NaN values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The command to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command contains NaN, false otherwise. </dd></dl>

</div>
</div>
<a id="abbafdee04c749eae1726dd6e76f52c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbafdee04c749eae1726dd6e76f52c0f">&#9670;&nbsp;</a></span>control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::control </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const ros::Time &amp;, const ros::Duration &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>ros_callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the currently active controller in a realtime loop.</p>
<p>If no controller is active, the function immediately exits. When running a controller, the function only exits when ros_callback returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_callback</td><td>A callback function that is executed at each time step and runs all ROS-side functionality of the hardware. Execution is stopped if it returns false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">franka::ControlException</td><td>if an error related to torque control or motion generation occurred. </td></tr>
    <tr><td class="paramname">franka::InvalidOperationException</td><td>if a conflicting operation is already running. </td></tr>
    <tr><td class="paramname">franka::NetworkException</td><td>if the connection is lost, e.g. after a timeout. </td></tr>
    <tr><td class="paramname">franka::RealtimeException</td><td>if realtime priority cannot be set for the current thread. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classfranka__hw_1_1_franka_combinable_h_w.html#a07855d935d7063930be9aa140d0895f8">franka_hw::FrankaCombinableHW</a>.</p>

</div>
</div>
<a id="a4014fbce5bae60ee693505775ecee499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4014fbce5bae60ee693505775ecee499">&#9670;&nbsp;</a></span>controlCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T franka_hw::FrankaHW::controlCallback </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&#160;</td>
          <td class="paramname"><em>ros_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const franka::RobotState &amp;&#160;</td>
          <td class="paramname"><em>robot_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">franka::Duration&#160;</td>
          <td class="paramname"><em>time_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback for the libfranka control loop. This method is designed to incorporate a second callback named ros_callback that will be called on each iteration of the callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The datafield containing the command to send to the robot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_callback</td><td>An additional callback that is executed every time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_state</td><td>The current robot state to compute commands with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_step</td><td>Time since last call to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>When a command contains NaN values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The command to be sent to the robot via libfranka. </dd></dl>

</div>
</div>
<a id="a8fcc0a82b0c13cdbd1de7fea38c3ecc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcc0a82b0c13cdbd1de7fea38c3ecc3">&#9670;&nbsp;</a></span>controllerActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::controllerActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether there is an active controller.</p>
<dl class="section return"><dt>Returns</dt><dd>True if a controller is currently active, false otherwise. </dd></dl>

</div>
</div>
<a id="ab29812769471d212a30dac6c19c12884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29812769471d212a30dac6c19c12884">&#9670;&nbsp;</a></span>doSwitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::doSwitch </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs controller switching (real-time capable). </p>

</div>
</div>
<a id="afb0f49fec764be80e4c89e29706a4936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0f49fec764be80e4c89e29706a4936">&#9670;&nbsp;</a></span>enforceLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::enforceLimits </td>
          <td>(</td>
          <td class="paramtype">const ros::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enforces limits on position, velocity, and torque level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The duration of the current cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f811d66ca087ad8ca387f7767e1df5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f811d66ca087ad8ca387f7767e1df5f">&#9670;&nbsp;</a></span>getCollisionThresholds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; franka_hw::FrankaHW::getCollisionThresholds </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>robot_hw_nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>defaults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set of collision thresholds from the parameter server. The methods returns the default values if no parameter was found or the size of the array did not match the defaults dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parameter to look for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_hw_nh</td><td>A node handle in the namespace of the robot hardware. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaults</td><td>A set of default values that also specify the size the parameter must have to be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set parsed parameters if valid parameters where found, the default values otherwise. </dd></dl>

</div>
</div>
<a id="ae8063f56d7e70e0f7537fe1d522f8f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8063f56d7e70e0f7537fe1d522f8f2f">&#9670;&nbsp;</a></span>getJointEffortCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 7 &gt; franka_hw::FrankaHW::getJointEffortCommand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the current joint torque command.</p>
<dl class="section return"><dt>Returns</dt><dd>The current joint torque command. </dd></dl>

</div>
</div>
<a id="a80bc3da19575532ab827bc9c62f91bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bc3da19575532ab827bc9c62f91bed">&#9670;&nbsp;</a></span>getJointPositionCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 7 &gt; franka_hw::FrankaHW::getJointPositionCommand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the current joint position command.</p>
<dl class="section return"><dt>Returns</dt><dd>The current joint position command. </dd></dl>

</div>
</div>
<a id="a93067ec2c8ba530188ee70f024ddf100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93067ec2c8ba530188ee70f024ddf100">&#9670;&nbsp;</a></span>getJointVelocityCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 7 &gt; franka_hw::FrankaHW::getJointVelocityCommand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the current joint velocity command.</p>
<dl class="section return"><dt>Returns</dt><dd>The current joint velocity command. </dd></dl>

</div>
</div>
<a id="a0323c9d759de8d6ab8fae4bf574e4a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0323c9d759de8d6ab8fae4bf574e4a48">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::init </td>
          <td>(</td>
          <td class="paramtype">ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>root_nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>robot_hw_nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="classfranka__hw_1_1_franka_h_w.html">FrankaHW</a> class to be fully operational. This involves parsing required configurations from the ROS parameter server, connecting to the robot and setting up interfaces for the ros_control framework.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root_nh</td><td>A node handle in the root namespace of the control node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_hw_nh</td><td>A node handle in the namespace of the robot hardware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a55d479321248ff8bcf80fc73ebb95d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d479321248ff8bcf80fc73ebb95d16">&#9670;&nbsp;</a></span>initParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::initParameters </td>
          <td>(</td>
          <td class="paramtype">ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>root_nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>robot_hw_nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the parameterization of the hardware class from the ROS parameter server (e.g. arm_id, robot_ip joint_names etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root_nh</td><td>A node handle in the root namespace of the control node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_hw_nh</td><td>A node handle in the namespace of the robot hardware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ad211498ff17ff1dfb9609a2fcf76d14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad211498ff17ff1dfb9609a2fcf76d14a">&#9670;&nbsp;</a></span>initRobot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::initRobot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses the robot_ip_ to connect to the robot via libfranka and loads the libfranka model. </p>

</div>
</div>
<a id="ae2775ed9705ec3d1d3e58aea2ce21bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2775ed9705ec3d1d3e58aea2ce21bde">&#9670;&nbsp;</a></span>initROSInterfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::initROSInterfaces </td>
          <td>(</td>
          <td class="paramtype">ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>robot_hw_nh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the class in terms of ros_control interfaces. Note: You have to call initParameters beforehand. Use the complete initialization routine <a class="el" href="classfranka__hw_1_1_franka_h_w.html#a0323c9d759de8d6ab8fae4bf574e4a48">init()</a> method to control robots.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_hw_nh</td><td>A node handle in the namespace of the robot hardware. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classfranka__hw_1_1_franka_combinable_h_w.html#a1e89406fc542ad7fb45ff0c1402c61c3">franka_hw::FrankaCombinableHW</a>.</p>

</div>
</div>
<a id="ab73b14d5f8481cd3cb3d670aeae2de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73b14d5f8481cd3cb3d670aeae2de06">&#9670;&nbsp;</a></span>prepareSwitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::prepareSwitch </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; hardware_interface::ControllerInfo &gt; &amp;&#160;</td>
          <td class="paramname"><em>stop_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepares switching between controllers (not real-time capable).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_list</td><td>Controllers requested to be started. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_list</td><td>Controllers requested to be stopped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the preparation has been successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a8494bbab229cd16bc9bb7c994b01684d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8494bbab229cd16bc9bb7c994b01684d">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::read </td>
          <td>(</td>
          <td class="paramtype">const ros::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ros::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads data from the franka robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The current time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The time passed since the last call to <a class="el" href="classfranka__hw_1_1_franka_h_w.html#a8494bbab229cd16bc9bb7c994b01684d">read</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classfranka__hw_1_1_franka_combinable_h_w.html#a44e3093eb876aef71423c4f5142c7ed8">franka_hw::FrankaCombinableHW</a>.</p>

</div>
</div>
<a id="aaa0bc020099cb6dba41728252d0c7df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0bc020099cb6dba41728252d0c7df4">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the limit interfaces. </p>

</div>
</div>
<a id="ade38eaa271d71cebb8bce3635cf82169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade38eaa271d71cebb8bce3635cf82169">&#9670;&nbsp;</a></span>robot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">franka::Robot &amp; franka_hw::FrankaHW::robot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Getter for the libfranka robot instance. </p>

</div>
</div>
<a id="a910bb11c6a3b14f027ad56dcf0d983c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910bb11c6a3b14f027ad56dcf0d983c7">&#9670;&nbsp;</a></span>setRunFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool franka_hw::FrankaHW::setRunFunction </td>
          <td>(</td>
          <td class="paramtype">const ControlMode &amp;&#160;</td>
          <td class="paramname"><em>requested_control_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">franka::ControllerMode&#160;</td>
          <td class="paramname"><em>internal_controller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures the run function which is used as libfranka control callback based on the requested control mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">requested_control_mode</td><td>The control mode to configure (e.g. torque/position/velocity etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit_rate</td><td>Flag to enable/disable rate limiting to smoothen the commands. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutoff_frequency</td><td>The cutoff frequency applied for command smoothing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_controller</td><td>The internal controller to use when using position or velocity modes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a16128e9789d933e1fcb3f9fc6e336eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16128e9789d933e1fcb3f9fc6e336eb1">&#9670;&nbsp;</a></span>setupFrankaCartesianPoseInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::setupFrankaCartesianPoseInterface </td>
          <td>(</td>
          <td class="paramtype">franka::CartesianPose &amp;&#160;</td>
          <td class="paramname"><em>pose_cartesian_command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures and registers the command interface for Cartesian poses in ros_control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose_cartesian_command</td><td>The data field holding the command to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e7f8225648735e054d8b022efee557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e7f8225648735e054d8b022efee557">&#9670;&nbsp;</a></span>setupFrankaCartesianVelocityInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::setupFrankaCartesianVelocityInterface </td>
          <td>(</td>
          <td class="paramtype">franka::CartesianVelocities &amp;&#160;</td>
          <td class="paramname"><em>velocity_cartesian_command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures and registers the command interface for Cartesian velocities in ros_control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">velocity_cartesian_command</td><td>The data field holding the command to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d738b3573b7ab159209b7e2e0d4a802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d738b3573b7ab159209b7e2e0d4a802">&#9670;&nbsp;</a></span>setupFrankaModelInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::setupFrankaModelInterface </td>
          <td>(</td>
          <td class="paramtype">franka::RobotState &amp;&#160;</td>
          <td class="paramname"><em>robot_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures and registers the model interface offering kinematics and dynamics in ros_control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_state</td><td>A reference to the data field storing the current robot state. This state is used to evaluate model qunatities (by default) at the current state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dbc96ed57e3054db31bbab11a61afec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbc96ed57e3054db31bbab11a61afec">&#9670;&nbsp;</a></span>setupFrankaStateInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::setupFrankaStateInterface </td>
          <td>(</td>
          <td class="paramtype">franka::RobotState &amp;&#160;</td>
          <td class="paramname"><em>robot_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures and registers the state interface offering the full franka::RobotState in ros_control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_state</td><td>The data field holding the updated robot state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34e707d6e834267f1ad256da5cce0713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e707d6e834267f1ad256da5cce0713">&#9670;&nbsp;</a></span>setupJointCommandInterface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::setupJointCommandInterface </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; double, 7 &gt; &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">franka::RobotState &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_q_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures and registers a joint command interface for positions velocities or efforts in ros_control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The data field holding the command to execute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The data field holding the updated robot state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_q_d</td><td>Flag to configure using desired values as joint_states. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">interface</td><td>The command interface to configure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab216faba5316b7ca1680e9af5d313216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab216faba5316b7ca1680e9af5d313216">&#9670;&nbsp;</a></span>setupJointStateInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::setupJointStateInterface </td>
          <td>(</td>
          <td class="paramtype">franka::RobotState &amp;&#160;</td>
          <td class="paramname"><em>robot_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures and registers the joint state interface in ros_control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_state</td><td>The data field holding the updated robot state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a476a1de741f79695f0b64d2580e6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a476a1de741f79695f0b64d2580e6cf">&#9670;&nbsp;</a></span>setupLimitInterface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::setupLimitInterface </td>
          <td>(</td>
          <td class="paramtype">joint_limits_interface::JointLimitsInterface&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>limit_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hardware_interface::JointCommandInterface &amp;&#160;</td>
          <td class="paramname"><em>command_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures a limit interface to enforce limits on effort, velocity or position level on joint commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">limit_interface</td><td>The limit interface to set up. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">command_interface</td><td>The command interface to hook the limit interface to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a064557fa9f0f7cb8e7cfab27eae03eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064557fa9f0f7cb8e7cfab27eae03eb8">&#9670;&nbsp;</a></span>setupParameterCallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::setupParameterCallbacks </td>
          <td>(</td>
          <td class="paramtype">ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>robot_hw_nh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the callbacks for on-the-fly reading the parameters for rate limiting, internal controllers and cutoff frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_hw_nh</td><td>A node handle in the namespace of the robot hardware. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8f348151b93a7eebc9ef45a702a29ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f348151b93a7eebc9ef45a702a29ee">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::update </td>
          <td>(</td>
          <td class="paramtype">const franka::RobotState &amp;&#160;</td>
          <td class="paramname"><em>robot_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the controller interfaces from the given robot state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">robot_state</td><td>Current robot state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcdec49ec8bb07c48ed3d77ea2cd4e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdec49ec8bb07c48ed3d77ea2cd4e46">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void franka_hw::FrankaHW::write </td>
          <td>(</td>
          <td class="paramtype">const ros::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ros::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes data to the franka robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The current time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The time passed since the last call to <a class="el" href="classfranka__hw_1_1_franka_h_w.html#afcdec49ec8bb07c48ed3d77ea2cd4e46">write</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classfranka__hw_1_1_franka_combinable_h_w.html#ab96f9d6af06fbd7569d8a059d1bfbdd4">franka_hw::FrankaCombinableHW</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/zheng/catkin_ws/src/franka_ros/franka_hw/include/franka_hw/<a class="el" href="franka__hw_8h_source.html">franka_hw.h</a></li>
<li>/home/zheng/catkin_ws/src/franka_ros/franka_hw/src/franka_hw.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
